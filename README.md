# Wrapp - Redis Process Wrapper for NVIDIA Orin

A high-performance process wrapper optimized for NVIDIA Orin AGX (Cortex-A78AE) that streams application output to Redis with advanced features like crash detection, core dump analysis, and multi-line log handling.

## üéØ Target Platform

This tool is specifically optimized for:
- **NVIDIA Jetson AGX Orin 32GB**
- **CPU**: Cortex-A78AE (12-core ARM v8.2 64-bit CPU, 3MB L2 + 6MB L3)
- **Architecture**: ARMv8.2-A with Crypto Extensions and LSE (Large System Extensions)

## Overview

Wrapp is a Go-based process wrapper designed to execute and monitor applications while streaming their output to Redis. Originally part of the Jettison project, it has been extracted and optimized specifically for NVIDIA Orin platforms.

## Key Features

- **Redis Streaming**: Real-time stdout/stderr streaming to Redis
- **Crash Detection**: Automatic core dump detection and GDB analysis
- **Multi-line Support**: Handles multi-line logs with special delimiters
- **User Switching**: Can run processes as different users (when run as root)
- **Health Monitoring**: Continuous Redis connection monitoring
- **Metadata Extraction**: Parses special markers in output for metrics
- **Session Management**: Tracks process runs with start/end markers
- **Orin Optimization**: Built with ARM64 v8.2 + crypto + LSE extensions

## Architecture

### Redis Database Usage

- **DB 1 (Logs)**: Stores application logs in Redis Streams
- **DB 2 (Values)**: Stores extracted metrics and key-value pairs
- **DB 5 (Config)**: Used for configuration and control

### Stream Structure

Logs are organized in Redis Streams using the configurable `stream_name`:
- `logs:app:<stream_name>:info` - Standard output logs
- `logs:app:<stream_name>:status` - Status messages and run markers
- `logs:app:<stream_name>:error` - Error messages
- `logs:app:<stream_name>:crash` - Crash reports and backtraces

## Installation

### Prerequisites

- Go 1.23 or later (for building from source)
- Redis server
- GDB (optional, for core dump analysis)
- NVIDIA Jetson AGX Orin (target platform)

### Building from Source

#### On NVIDIA Orin (Native Build)

```bash
# Clone the repository
git clone https://github.com/yourusername/wrapp.git
cd wrapp

# Download dependencies
make deps

# Build release version (no debug output)
make release

# Or build debug version (with debug output)
make dev

# Install to system
sudo make install          # Installs release version
sudo make install-dev      # Installs debug version
```



## Configuration

Wrapp uses a JSON configuration file with ridler-compatible secret management:

```json
{
  "redis": {
    "host": "localhost",
    "port": 6379,
    "secrets_dir": "/run/jon_secrets/vault/redis/wrapp"
  },
  "app": {
    "executable": "/usr/local/bin/myservice",
    "args": ["--config", "/etc/myservice.conf", "--verbose"],
    "user": "serviceuser",
    "stream_name": "myservice"
  }
}
```

### Redis Credentials

Instead of hardcoding passwords, wrapp reads credentials from a directory generated by [jettison_ridler](https://github.com/lpportorino/jettison_ridler):

- **Username**: Inferred from directory basename (e.g., `wrapp` from `/run/jon_secrets/vault/redis/wrapp`)
- **Password**: Read from `<secrets_dir>/password` file

**Example ridler config** (`/etc/ridler/spec.json`):
```json
{
  "version": 1,
  "vault_root": "/run/jon_secrets/vault",
  "items": [
    {
      "name": "wrapp_redis",
      "type": "redis",
      "path": "redis/wrapp",
      "user": "wrapp",
      "length": 32
    }
  ]
}
```

This generates:
```
/run/jon_secrets/vault/redis/wrapp/
‚îú‚îÄ‚îÄ password  (wrapp reads this)
‚îî‚îÄ‚îÄ acl       (Redis server uses this)
```

## Step Debugging with GDB

Wrapp supports remote debugging via gdbserver, allowing you to step through your wrapped application **before it reaches `main()`**. The process starts paused at the first instruction after `execve`, giving you full control from the very beginning.

### Prerequisites

- **Ubuntu 22.04 variant** container image (includes gdb/gdbserver)
- Container with **`SYS_PTRACE` capability** and relaxed seccomp profile
- GDB or CLion on your development machine

### Configuration

Add a `"debug"` section to your JSON config:

```json
{
  "debug": {
    "enabled": true,
    "port": 2345,
    "host": "127.0.0.1"
  }
}
```

### Container Requirements

#### Podman/Docker CLI

```bash
podman run -it --rm \
  --cap-add=SYS_PTRACE \
  --security-opt seccomp=unconfined \
  -p 2345:2345 \
  -v $(pwd)/config.json:/config.json:ro \
  ghcr.io/lpportorino/jettison-base-ubuntu22:latest \
  wrapp /config.json
```

**Why these options are required:**
- `--cap-add=SYS_PTRACE`: Allows wrapp to use ptrace syscalls to pause the child process
- `--security-opt seccomp=unconfined`: Allows ptrace, waitpid, and other debugging syscalls
- `-p 2345:2345`: Exposes gdbserver port for remote connection

#### Quadlet Configuration (`.container` file)

```ini
[Container]
Image=ghcr.io/lpportorino/jettison-base-ubuntu22:latest
Volume=/etc/myapp/config.json:/config.json:ro,Z
PublishPort=2345:2345
SecurityOpt=seccomp=unconfined
AddCapability=SYS_PTRACE
Exec=wrapp /config.json

[Service]
Restart=on-failure

[Install]
WantedBy=default.target
```

### Connecting with GDB

From your development machine:

```bash
# Start GDB with the executable
gdb /path/to/executable

# Connect to gdbserver
(gdb) target remote <host>:2345

# Process is paused at first instruction
# Set breakpoints
(gdb) break main
(gdb) break some_function

# Continue execution
(gdb) continue

# Step through code
(gdb) step
(gdb) next
```

### Connecting with CLion

1. **Run ‚Üí Edit Configurations ‚Üí + ‚Üí Remote GDB Server**
2. **Configuration**:
   - **'target remote' args**: `<host>:2345`
   - **Symbol file**: Upload executable or use local copy
   - **Path mappings** (if needed): Container `/` ‚Üí Local path
3. **Start Debug Session**: Click debug icon
4. **Set breakpoints** and step through code

### Remote Debugging (SSH Tunnel)

For secure remote debugging, use an SSH tunnel instead of binding to `0.0.0.0`:

```bash
# On dev machine: Create SSH tunnel
ssh -L 2345:localhost:2345 archer@jetson.local

# In config.json: Bind to localhost only
{
  "debug": {
    "enabled": true,
    "port": 2345,
    "host": "127.0.0.1"
  }
}

# On dev machine: Connect GDB to localhost
gdb /path/to/executable
(gdb) target remote localhost:2345
```

### How It Works

1. **Wrapp starts the child process** with `PTRACE_TRACEME`, causing it to stop immediately after `execve` (before any code runs)
2. **Wrapp detaches** from ptrace while keeping the process stopped
3. **gdbserver launches** and attaches to the stopped process
4. **Process remains paused** until your debugger connects and continues execution

This approach gives you complete control from the first instruction, even before `main()` or any library initialization code runs.

### Example Debug Sessions

See the `examples/` directory:
- `debug-simple.json` - Basic local debugging
- `debug-remote.json` - Remote debugging with SSH tunnel
- `debug-container.json` - Container-based debugging

### Security Considerations

**‚ö†Ô∏è WARNING: Debug mode is for development only**

- **gdbserver has no authentication** - anyone who can connect to the port has full control over the process
- **Bind to `127.0.0.1` by default** to restrict access to localhost
- **Use SSH tunnels** for remote debugging instead of binding to `0.0.0.0`
- **Never enable debug mode in production** - it pauses the process until a debugger connects
- **Use firewall rules** to restrict port 2345 access

### Troubleshooting

#### "Operation not permitted" errors

**Cause**: Container doesn't have `SYS_PTRACE` capability

**Fix**: Add `--cap-add=SYS_PTRACE` and `--security-opt seccomp=unconfined`

#### Process hangs at startup

**Expected behavior**: When debug mode is enabled, the process waits for a debugger to connect. Check the wrapp output for connection instructions.

#### "Connection refused" when connecting GDB

**Check**:
1. Port is published: `-p 2345:2345`
2. gdbserver is listening: Check wrapp logs
3. Firewall allows connection
4. Correct host address (use `localhost` if SSH tunnel)

#### Can't set breakpoints

**Cause**: GDB doesn't have debug symbols

**Fix**: Ensure you're using the same executable binary that's running in the container, or provide symbol file path in CLion

## Usage

### Basic Usage

```bash
wrapp <config.json>
```

That's it! Everything is configured in the JSON file.

### Examples

See `config.example.json` for a complete configuration example.

```bash
# Run with a configuration file
wrapp config.json

# Run as root to switch users (drops to configured user)
sudo wrapp service-config.json
```

### Advanced Features

#### Multi-line Log Handling

Use special delimiters for multi-line logs:
```
Normal log line
>>|Start of multi-line
content spans
multiple lines|<<
Another normal line
```

#### Metric Extraction

Embed special markers in output:
```
{{counter}}        # Increment a counter
{{value:42}}       # Set a specific value
```

Stored in Redis DB 2: `wrapp:<stream_name>:<key>`

#### Core Dump Analysis

Enable core dumps before running:
```bash
ulimit -c unlimited
echo "/tmp/core-%E-%t-%p-%s" | sudo tee /proc/sys/kernel/core_pattern
```

## Build System

### Makefile Targets

| Target | Description |
|--------|-------------|
| `make release` | Build production version (no debug output) |
| `make dev` | Build debug version (with debug logging) |
| `make build` | Alias for `make release` |
| `make install` | Install release version to `/usr/local/bin` |
| `make install-dev` | Install debug version to `/usr/local/bin` |
| `make clean` | Remove build artifacts |
| `make deps` | Update Go dependencies |
| `make test` | Run tests |
| `make help` | Show all available targets |

### Debug vs Release Builds

- **Release Build** (`make release`):
  - No debug output
  - Optimized binary size (~5.2MB)
  - Production use

- **Debug Build** (`make dev`):
  - Timestamped debug output to stderr
  - Shows configuration, arguments, user switching, etc.
  - Larger binary size (~7.7MB)
  - Development and troubleshooting

Debug output format: `[DEBUG HH:MM:SS.mmm] Message`

### Build Optimization Details

The Orin build uses:
- `GOOS=linux` - Linux operating system
- `GOARCH=arm64` - 64-bit ARM architecture
- `GOARM64=v8.2,crypto,lse` - ARMv8.2-A with cryptographic and LSE extensions
- `-trimpath` - Remove file system paths from binary
- `-s -w` - Strip debug information for smaller binary


## Performance Considerations

### Orin-Specific Optimizations

1. **LSE (Large System Extensions)**: Improves atomic operations performance
2. **Crypto Extensions**: Hardware-accelerated cryptography
3. **Memory Ordering**: Optimized for ARM64 memory model
4. **Trimmed Binaries**: Smaller size for faster loading

### Redis Performance

- Streams are capped at 1000 entries with approximate trimming
- Pipeline operations for batch writes
- Separate connections for logs, values, and config
- 60-second keep-alive pings

## Development

### Project Structure

```
.
‚îú‚îÄ‚îÄ wrapp.go                 # Main source code
‚îú‚îÄ‚îÄ debug_on.go              # Debug logging implementation (debug builds)
‚îú‚îÄ‚îÄ debug_off.go             # No-op logging (release builds)
‚îú‚îÄ‚îÄ build/                   # Build output directory
‚îú‚îÄ‚îÄ config.example.json      # Full configuration example
‚îú‚îÄ‚îÄ go.mod                   # Go module definition
‚îú‚îÄ‚îÄ go.sum                   # Dependency checksums
‚îú‚îÄ‚îÄ Makefile                 # Build automation
‚îî‚îÄ‚îÄ README.md                # This file
```

### Testing on Different Platforms

```bash
# Test on Orin (native)
make test

# Test locally (builds for current architecture)
go build -o build/wrapp-local .
./build/wrapp-local config.json
```

### Debugging

```bash
# Build debug version with logging enabled
make dev

# Run debug version to see detailed output
./build/wrapp-debug config.json

# Debug output includes:
# - Configuration loading and values
# - Redis credentials loading (username inferred from directory)
# - Redis connection attempts
# - User determination logic
# - Process execution details (PID, exit code)
# - Command construction
```

## Troubleshooting

### Common Issues

#### Redis Connection Failed
```bash
# Check Redis status
systemctl status redis
redis-cli ping

# Verify configuration
cat config.json

# Check secrets are readable
sudo ls -la /run/jon_secrets/vault/redis/wrapp/
sudo cat /run/jon_secrets/vault/redis/wrapp/password
```

#### Secrets Not Found
```bash
# Ensure ridler ran successfully
sudo systemctl status ridler.service

# Check vault directory exists
ls -la /run/jon_secrets/vault/

# Verify permissions (should be mode 0400, owned by root)
sudo ls -la /run/jon_secrets/vault/redis/wrapp/
```

#### Core Dumps Not Generated
```bash
# Check ulimits
ulimit -c

# Set unlimited
ulimit -c unlimited

# Verify core pattern
cat /proc/sys/kernel/core_pattern
```

#### Binary Architecture Mismatch
```bash
# Verify binary architecture
file wrapp
# Should show: ELF 64-bit LSB executable, ARM aarch64

# Check Go build info
go version -m wrapp
```

## Performance Metrics

On NVIDIA Orin AGX 32GB:
- Startup time: <10ms
- Memory usage: ~10MB baseline
- CPU usage: <1% idle, scales with log volume
- Log throughput: >100k lines/second
- Latency: <1ms Redis write

## License

This tool was extracted from the Jettison project. Please refer to the original project for licensing information.

## Support

For issues, feature requests, or questions:
1. Check the [Issues](https://github.com/yourusername/wrapp/issues) page
2. Review existing documentation
3. Create a new issue with detailed information

## Credits

Originally developed as part of the Jettison project's Redis logging infrastructure, optimized for NVIDIA Orin AGX platforms.